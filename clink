#!/bin/bash

verbose_echo() {
    if [ ! -z $CLINK_VERBOSITY ]; then
        fd="--stderr"
    fi
    logger --id $fd --tag "clink" -- "$@"
}

need_item() {
    if [ -z $1 ]; then
        echo "Not enough input"
        exit 1
    fi
}

display_usage() {
    echo "usage: $(basename $0) [--install-shell-func] | [--get IMAGE] | [--help]"
    echo
    echo "Flags:"
    echo "  --install-shell-func IMAGE"
    echo "  --get IMAGE"
    echo
    echo "Environment variables:"
    echo "  CLINK_VERBOSITY: When set, clink will echo extra information."
    echo "  DOCKER_HUB_USER: Set this to the name of a Docker hub user or private registry namespace."
    echo " CLINK_REGISTRIES: Semicolon-separated list of private registry namespaces."
    echo "  CLINK_RUN_FLAGS: Extra flags to pass to docker run."
    echo
    echo "Help:"
    echo "  -h, --help"
    echo
    echo "This program should not be executed directly in most cases. Instead, "
    echo "you should source it by adding the following line to your profile:"
    echo
    echo "source $(readlink -f $0)"
}

run_cli() {
    case "$1" in
    --install-shell-func)
        # fixme: not sure what this should actually do
        :
        ;;
    --ls|--list)
        images=$(docker images | grep -v ^REPOSITORY | cut -d" " -f1 | sort | uniq)
        echo "$images"
        ;;
    --link)
        shift
        run_source
        echo "  Make sure your image is tagged $1:"
        echo "docker tag IMAGE $1"
        echo "  Then create a symlink in your path to clink:"
        echo "ln -s $SCRIPT_DIR/clink $HOME/bin/$1"
        ;;
    --get)
        shift
        need_item $1
        image=$1
        docker pull $image
        ;;
    -h|--help)
        display_usage
        exit 1
        ;;
    *)
        need_item $0
        image=$(basename $0)
        if [ $image = "clink" ]; then
            display_usage && return
        fi
        verbose_echo "Running: $image $@"
        run_source
        command_not_found "$image" "$@"
    esac
}

dereference() {
    # Dereference a symlink.
    # We could use "readlink -f", but OSX doesn't support it.
    # So we're in for a world of pain instead.
    if ! [ -e "$1" ]; then
        # Don't even try if:
        # - the symlink doesn't exist
        # - the symlink points to nothing
        # - the symlink has a loop
        return 1
    fi
    if ! [ -L "$1" ]; then
        # If the parameter is not a symlink: we're done.
        echo "$1"
        return 0
    fi
    TARGET=$(readlink "$1")
    case "$TARGET" in
    /*)
        dereference "$TARGET" ;;
    *)
        dereference "$(dirname "$1")/$TARGET" ;;
    esac
}

run_source() {
    # Bail if we are already in a container
    [ -e /.dockerenv ] && {
        echo "already in a container"
        return
    }

    # Find out our true path (in case we're a symlink).
    SCRIPT_PATH="$(dereference "$SCRIPT_FILE")"
    [ -z "$SCRIPT_PATH" ] && {
        echo "could not find our true path"
        return
    }
    SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
    source "$SCRIPT_DIR/source_commands"
}

# We need to find out:
# - where we are installed,
# - if we are executed or sourced.
# Detection mechanisms will depend on the shell used.

if [[ -n "${BASH_SOURCE[0]}" ]]; then
    # This special variable is set only in bash.
    # It is *always* the name of the file.
    SCRIPT_FILE="${BASH_SOURCE[0]}"
    # If we are executed, $0 is the name of the file.
    if [[ "$SCRIPT_FILE" = "$0" ]]; then
        SCRIPT_MODE=exec
    else
        SCRIPT_MODE=source
    fi
fi

if [[ -n "$ZSH_EVAL_CONTEXT" ]]; then
    # This special variable is set only in zsh.
    SCRIPT_FILE="$0"
    # ZSH_EVAL_CONTEXT is "toplevel" when we are executed,
    # and "toplevel:file" if we are sourced.
    if [[ "$ZSH_EVAL_CONTEXT" = toplevel ]]; then
        SCRIPT_MODE=exec
    else
        SCRIPT_MODE=source
    fi
fi

case "$SCRIPT_MODE" in
    source) run_source;;
    exec) run_cli "$@";;
    *) echo "Sorry, I could not detect which shell you are using.";;
esac


